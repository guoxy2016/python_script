## Python面试题

### python编程

1. `*args`和`**kwargs`参数的含义和使用方法

    `*args`和`**kwargs`可以叫它们可变长参数, 这俩都是用来收集参数的, 不同的是`*args`用来收集位置参数, `**kwargs`收集关键字参数,
    所以`*args`可以称作可变长位置参数, `**kwargs`可以称作可变长关键字参数, `*args`一般在普通位置参数之后, 用来收集匹配完位置参数
    之后多余的位置参数, `**kwargs`一般放在关键字参数或是默认参数之后, 收集多余的以`key=value`形式传递的参数. 在python3以后`*args`
    也可以放到位置参数之前, 不过, 这时`*args`之后的位置参数就变成了关键字参数了, 只能通过`key=value`形式传入. 还有一点要指出
    `**kwargs`必须放在最后.

    上述情况用于函数参数情形, `*args`和`**kwargs`也会用在函数调用的情形, 这时`*args`的作用是将`args`解包, 把元组或列表(set也可以
    解包, 不过set是无序的所以传参肯定是不能用的了. "字符串, bytearrary, bytes"也可以解包, 但一般不会用在传参吧)按位置参数的形式传
    递给函数. `**kwargs`的作用只是把字典转换成`key=value`的形式传递给函数. 

2. 描述一下python2和python3的区别，比如类型检查等

    - str: python2中str表示的是二进制的ascii字符, unicode字符需要通过u''的形式指定, 在python3中的str指的是unicode字符, 和python2
    中str相对应的是bytes字符通过b''指定.
    - open(): 与str相对应, 使用open函数打开文件时, python2打开的是二进制文件, python3打开的文件需要分情况讨论, 打开方式中没有'b'
    则打开unicode形式的文件, 包含'b'则打开二进制形式的文件.
    - 类: python2中, 类可以分为没有继承自object的经典类, 以及继承自object的新式类. python3的类都是继承自object的新式类.
    - print: python2中pirnt是一条语句, python3中print是一个函数, 可以指定更多的内容.
    - 函数工具: filter, map, range等函数工具在python3中都变成了生成器, 需要迭代才能取出值.
    - int: python2中的int和long在python3中整合为int, int包含long.
    - /: python2中的除法更具被除数和除数的类型返回int或float. python3的除法只返回float

3. 请列常用的python library，并说明其作用基本使用示例 

    logging, glob, re, io, os.path os, functool, datetime, random,

    - logging: 记录日志, 可以设置各种类型的日志, 包括自动发送Error错误邮件等
        ```py
        import logging
        from logging import StreamHandler
        from logging.handlers import TimedRotatingFileHandler

        logger = logging.getLogger(__name__)  #指定日志名称
        logger.setLevel(logging.INFO)  # 设置等级

        file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(lineno)s: %(message)s') # 文件日志格式
        file_handler = TimedRotatingFileHandler('data.log', when='midnight')  # 过了0点切换文件
        file_handler.setLevel(logging.INFO)  # 当前文件日志等级
        file_handler.setFormatter(file_formatter)  # 
        logger.addHandler(file_handler)
        logger.addHandler(StreamHandler)  # 添加一个默认流处理

        def func():
            try:
                r = 1 / 0
            except Exception as e:
                logger.error(e)

        if __name__ == '__main__':
            func()
        ```
    - glob: 查找文件
        ```py
        import glob

        result = glob.glob(r'./*.py')  # 参数传递的是文件路径, 可使用*等通配符匹配文件.
        print(result)
        ```
    - re: 正则匹配
        ```py
        import re
        result = re.search(r'[j].{3}', 'asecsedsjavcccjccc')
        print(result.group(0))
        ```
        返回javc
    
    - datetime: 时间, 日期, 时间间隔等类的集合
        ```py
        import datetime
        time = datetime.timedelta(days=1, hours=2)
        print(time.total_seconds())
        ```
        展示一天2小时有多少秒
    
    - io: 处理流的核心工具库, 模块提供了 Python 用于处理各种 I/O 类型的主要工具。三种主要的 I/O类型分别为: 文本 I/O(StringIO), 
    二进制 I/O(BytesIO)和 原始 I/O(RawIO)
        ```py
        import io

        data = io.StringIO()
        data.writ('zhangsanlisi王麻子')
        data.seek(0)
        pirnt(data.read())
        ```
        输出 zhangsanlisi王麻子 

4. 描述python开发中，协程，线程，进程以及asyncio的异同，请写一个python程序在多核CPU上并行执行

    * 协程: 一种轻量级微线程,它是程序级别的，在执行过程中可以中断去执行其它的子程序，别的子程序也可以中断回来继续执行之前的子
    程序，无需线程上下文切换的开销, 用于协程的库主要有greenlet, 高级的有gevent和eventlet主要用于高并发的网络应用
    * 线程: 线程是调度和分配的基本单位, 线程属于进程, 进程可以拥有多个线程, python的线程拥有GIL锁保证同一时刻只有一个线程占用
    CPU, 线程
    * 进程: 进程是资源的基本单位, 每一个进程会复制一份所有进程需要的资源, 除非进程之间有通讯否则, 进程之间的运算结果互不影响.
    * asyncio: asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。是构
    建 IO 密集型和高层级结构化网络代码的最佳选择。在标准库中属于网络和进程间通信这一部分,可见这是作要用在网络. 



### 正则表达式

1. re.search和re.match的区别

    `re.search`是在全文的任意位置只要匹配到就返回, `re.match`是从开头匹配, `re.search(r'^abc'...)`就相当与`re.match(r'abc'...)`

2. 贪婪匹配/非贪婪匹配区别

    贪婪指的是将匹配字符尽量匹配更多的字符, 非贪婪表示匹配更少的字符.

3. 请用python写一个正则表达式实现如下内容的匹配，并实现数据的结构化
    ```
    acb8af4a-02fb-4aa5-71ae-c3589jfabc0     AC009C    关于公司为全资子公司San Jose  USA, L.L.C.申请融资提供担保的公告    2018-02-29
    {
    'uuid': 'acb8af4a-02fb-4aa5-71ae-c3589jfabc0',
    'code': 'AC009C',
    'title': '关于公司为全资子公司San Jose USA,L.L.C.申请融资提供担保的公告',
    'date': '2018-02-29'
    }
    ```

    ```py
    import re

    s = 'acb8af4a-02fb-4aa5-71ae-c3589jfabc0     AC009C    关于公司为全资子公司San Jose  USA, L.L.C.申请融资提供担保的公告    2018-02-29'
    comp = re.compile(
        r'([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{11})[ ]*?'
        r'([A-Z0-9]{6})[ ]*'
        r'([\u4e00-\u9fa5A-Za-z0-9, .]+?)[ ]*?'
        r'([0-9]{4}-[0-9]{2}-[0-9]{2})')
    result = comp.match(s)
    if result:
        structure_data = dict(
            uuid=result.group(1).strip(),
            code=result.group(2).strip(),
            title=result.group(3).strip(),
            date=result.group(4).strip(),
        )
        print(structure_data)

    ```


### python程序调试方法

1. 某程序在运行的流程是监听网络需求，进行数据库读操作，运行相关算法，进行数据写操作，响应网络请求。如果整个处理流程很慢，该怎么进行诊断和监控

    借助python的profile或者cProfile库监控函数运行流程, 奖教慢的

2. python程序如何实现断点设置和单步调试，如何实现远程调试 (请分有IDE和没有IDE两种情况介绍)

    - 没有IDE:
        使用`python -m pdb file.py`运行文件, 这时文件会停在第一行, 使用n(ext)可以单步调试
        使用ssh工具登陆远程调试或者使用ssh在本地运行命令.

3. python程序如何打印当前执行的调用栈情况

    pass


### 编程问题

1. 实现flatten函数完成如下的转换功能
    ```
    nested_json = {
        "a": 1,
        "b": [35, 26],
        "c": [{
                "d": [2, 3, 4],
                "e": [
                    {
                        "f": 1,
                        "g": 2
                    }
                    ]
            }],
        "h": {}
        }
    flattened_json = flatten(nested_json)
    print(flattened_json)
    {'a': 1,
    'b.0': 35,
    'b.1': 26,
    'c.0.d.0': 2,
    'c.0.d.1': 3,
    'c.0.d.2': 4,
    'c.0.e.0.f': 1,
    'c.0.e.0.g': 2,
    'h': {}
    }
    ```

    ```py
    from pprint import pprint

    nested_json = {"a": 1, "b": [35, 26], "c": [{"d": [2, 3, 4], "e": [{"f": 1, "g": 2}]}], "h": {}}


    def flatten(data):
        if data and isinstance(data, dict):
            ret = dict()
            for key, value in data.items():
                result = flatten(value)
                if result and isinstance(result, dict):
                    for ret_key, ret_val in result.items():
                        ret[str(key) + '.' + str(ret_key)] = ret_val
                else:
                    ret[key] = result
            return ret
        elif data and isinstance(data, list):
            ret = dict()
            for key, value in enumerate(data):
                result = flatten(value)
                if result and isinstance(result, dict):
                    for ret_key, ret_val in result.items():
                        ret[str(key) + '.' + str(ret_key)] = ret_val
                else:
                    ret[str(key)] = result
            return ret
        else:
            return data


    pprint(flatten(nested_json))
    ```

2. 采用python3编写代码，完成如下的排序功能：
    ```
    输入：[(9, 2), (3, 7), (7, 8), (3, 5), (1, 9)]
    输出：[(1, 9), (3, 7), (3, 5), (7, 8), (9, 2)]
    ```
    满足：输入是二元组的列表，对这一组二元组进行排序，先按照二元组的第一个维度按照升序排序，然后按照二元组的第二个维度进行降序排列

    ```py
    def insert_sort(unsort):
    n = len(unsort)
    for i in range(1, n):
        for j in range(i - 1, -1, -1):
            if unsort[j + 1][0] < unsort[j][0]:
                unsort[j + 1], unsort[j] = unsort[j], unsort[j + 1]
            elif unsort[j + 1][0] == unsort[j][0] and unsort[j + 1][1] > unsort[j][1]:
                unsort[j + 1], unsort[j] = unsort[j], unsort[j + 1]
            else:
                break
    return unsort
    ```


## Linux面试题

1. 假设这里有一台服务器地址为192.168.0.2，开放的端口为6623，如何连接到远程服务器操作？

    使用ssh, 将远程ssh默认端口改为6623, 然后连接`ssh -p 6623 username@ipaddress`

2. 假设这里有一台服务器地址为192.168.0.2，开放的端口为6623，怎么将服务器的/opt/data的文件拷到本地目录？

    同样县修改端口, 然后使用scp复制文件命令:`scp -P 6623 username@ipaddress:/file/to/path /target/file/to/path`

3. 通过`python server.py`开启了某个服务，现在该服务失去响应了，请问如何找到这个进程，并杀掉。

    使用ps加grep查找pid人后kill命令:
    ps aux | grep 'python server.py'
    输出: username  pid  ...
    kill pid

4. 列出文件夹下所有json文件，并删除昨天创建的文件

    find -type f -name '*.json'; 
    find -type f -name '*.json' -ctime -1 -exec rm {} \;

5. 如何查看系统某个端口是否已经被其他程序占用

    `netstat  -anp  |grep   端口号`

6. 在执行Linux命令时，如果既想把输出保存到文件中，又想在屏幕上看到输出内容，该如何处理

    command ... > resd.txt | cat resd.txt

7. git rebase命令和git merge命令有什么区别，2个命令对系统会造成什么影响。

    rebase 历史体提交合并到当前分支, merge只合并到当前分支, 
    rebase会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。
    merge 会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交

8. 列举经常使用的系统监控命令，包括网络，CPU，GPU等使用情况的监控，

    1、CPU内存监控
    （1）$ top
    （2）htop，首先要安装htop
    $ sudo apt-get install htop
    $ htop
    2、GPU内存使用情况
    （1）单次查看
    $ nvidia-smi
    （2）实时监控，将上面的命令配合watch使用，使其每秒钟刷新一次。
    $ watch -n 1 nvidia-smi

9. 文件系统写不入数据，初步检查发行文件系统是可写的，而且还有30%的空间没有使用，请尝试分析一下可能存在问题

    写到没有权限的目录中去了, 或写入的指令有错

10. 如何设置定时任务，如果定时任务执行命令的结果和在命令行直接执行该命令的结果不同，请考虑可能存在什么问题

    环境的问题, 比如在命令行中使用了虚拟环境, 或设置了不同的环境变量.

11. pip安装程序包太慢了怎么处理，apt命令 安装程序包太慢了怎么处理

    切换国内的源
    pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 临时
    修改 ~/.pip/pip.conf (没有就创建一个)内容:
    ```
    [global]
    index-url = https://pypi.tuna.tsinghua.edu.cn/simple
    ```


## 其他：

1. 请介绍一下你项目中用到的技术栈，觉得得意和出色的点，让你头疼的点以及怎么解决的

    socketio, jwt, oauth认证, 数据库事件监控, 数据监控使用横不错, 可以在数据保存或修给是做一些额外的操作比如, 删除数据后同步删除在线文件.
    长传图片是为了为更加安全验证文件类型, 不太好办, 直接使用PIL打开验证有点消耗资源, 后来找到了一个imghdr库使用它来验证文件的真实属性.

2. 请介绍一下最近看的5本书和为什么选择这5本

    python学习手册, 参考书, 了解python面向对象, 元类等的高级工具, 同时温故知新, 查看书中的细节, 充实对python的认知. 
    全球通史, 了解一些历史知识, 个人兴趣.
    sql数据库, 练习sql语句的书写的书
    python数据结构, 了解数据结构与算法总是没有错的, 学习队列, hash列表, 二叉树, 图, 以及各种常用算法.
    幸运心理学, 对心理学稍微有点爱好. 正好有空看一看.


3. 请简单描述您未来5年的规划

    学习好后端技术, 了解python擅长的人工智能和数据分析方向知识, 在技术上勇攀高峰, 有能力有技术总是不会吃亏的.
